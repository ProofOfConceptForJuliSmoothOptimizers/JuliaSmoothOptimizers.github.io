<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/previews/PR1/libs/katex/katex.min.css"> <link rel=stylesheet  href="/previews/PR1/libs/highlight/github.min.css"> <link rel=stylesheet  href="/previews/PR1/css/franklin.css"> <link rel=stylesheet  href="/previews/PR1/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/previews/PR1/assets/favicon.png"> <title>Introduction to Linear Operators</title> <link rel=stylesheet  href="/previews/PR1/css/custom.css"> <link rel=preconnect  href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=Nunito&family=Montserrat&display=swap" rel=stylesheet > <script src="/previews/PR1/libs/highlight/highlight.pack.js"></script> <!--TODO: Add EVERYTHING-->> <script> hljs.getLanguage('julia').keywords.custom = 'obj grad hess AbstractNLPModel'; </script>" <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/previews/PR1/assets/jso.png"> <h1><a href="/previews/PR1/">JSO</a></h1> <p class=lead >Julia Smooth Optimizers.</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/previews/PR1/">Home</a> <a class="sidebar-nav-item " href="/previews/PR1/pages/tutorials/list/">Tutorials</a> <a class="sidebar-nav-item " href="/previews/PR1/pages/ecosystem/list/">Ecosystems</a> <a class="sidebar-nav-item " href="/previews/PR1/pages/how-to/list/">How-to guide</a> <a class="sidebar-nav-item " href="/previews/PR1/pages/reference/list/">Reference guides</a> </nav> <p>&copy; Abel Soares Siqueira.</p> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=title ><a href="#title" class=header-anchor >Introduction to Linear Operators</a></h1> <div class=author >by Abel S. Siqueira</div> <p>LinearOperators.jl is a package for matrix-like operators. Linear operators are defined by how they act on a vector, which is useful in a variety of situations where you don&#39;t want to materialize the matrix.</p> <div class=franklin-toc ><ol><li><a href="#introduction">Introduction</a><li><a href="#lazy_products">Lazy Products</a><li><a href="#preallocated_operators">Preallocated Operators</a><li><a href="#inverse_operator">Inverse Operator</a><li><a href="#lbfgs_operator">LBFGS Operator</a><li><a href="#application_heat_equation">Application: Heat Equation</a></ol></div> <h2 id=introduction ><a href="#introduction" class=header-anchor >Introduction</a></h2> <pre><code class=language-julia >using LinearOperators

prod&#40;v&#41; &#61; &#91;3v&#91;1&#93; - v&#91;2&#93;; 2v&#91;1&#93; &#43; 2v&#91;2&#93;&#93;
A &#61; LinearOperator&#40;
  Float64, # element type
  2,       # number of rows
  2,       # number of columns
  false,   # symmetric?
  false,   # Hermitian?
  prod     # Function defining v → Av
&#41;

@show A
A * ones&#40;2&#41;</code></pre><pre><code class=plaintext >A = Linear operator
  nrow: 2
  ncol: 2
  eltype: Float64
  symmetric: false
  hermitian: false
  nprod:   0
  ntprod:  0
  nctprod: 0


2-element Array{Float64,1}:
 2.0
 4.0</code></pre> <p>The operator can be symmetric and/or Hermitian, and products with its transpose and adjoint can be defined as well.</p> <pre><code class=language-julia >prod&#40;v&#41; &#61; &#91;3v&#91;1&#93; - v&#91;2&#93;; 2v&#91;1&#93; &#43; 2v&#91;2&#93;&#93;
tprod&#40;v&#41; &#61; &#91;3v&#91;1&#93; &#43; 2v&#91;2&#93;; -v&#91;1&#93; &#43; 2v&#91;2&#93;&#93;

A &#61; LinearOperator&#40;Float64, 2, 2, false, false, prod, tprod&#41;

transpose&#40;A&#41; * ones&#40;2&#41;</code></pre><pre><code class=plaintext >2-element Array{Float64,1}:
 5.0
 1.0</code></pre> <p>Notice that since <code>A</code> defined above is real, then the adjoint transpose is inferred to also be <code>tprod</code>:</p> <pre><code class=language-julia >A&#39; * ones&#40;2&#41;</code></pre><pre><code class=plaintext >2-element Array{Float64,1}:
 5.0
 1.0</code></pre> <p>In the following example we define a complex operator using the Fast Fourier Transform and its inverse. Notice that the operator is orthogonal.</p> <pre><code class=language-julia >using FFTW, LinearAlgebra

A &#61; LinearOperator&#40;16, 16, false, false, fft, nothing, ifft&#41;

v &#61; rand&#40;16&#41; &#43; im * rand&#40;16&#41;
norm&#40;A * v - fft&#40;v&#41;&#41;, norm&#40;A&#39; * v - ifft&#40;v&#41;&#41;, norm&#40;Matrix&#40;A&#39; * A&#41; - I&#41;</code></pre><pre><code class=plaintext >(0.0, 0.0, 1.9812853513207183e-16)</code></pre>
<h2 id=lazy_products ><a href="#lazy_products" class=header-anchor >Lazy Products</a></h2>
<p>One immediate advantage of LinearOperators is that it allows lazy matrix products.</p>
<pre><code class=language-julia >n &#61; 4000
A &#61; rand&#40;n, n&#41;
B &#61; rand&#40;n, n&#41;
opA &#61; LinearOperator&#40;A&#41;
opB &#61; LinearOperator&#40;B&#41;

@show opA * opB</code></pre><pre><code class=plaintext >opA * opB = Linear operator
  nrow: 4000
  ncol: 4000
  eltype: Float64
  symmetric: false
  hermitian: false
  nprod:   0
  ntprod:  0
  nctprod: 0


</code></pre>
<p>Run twice</p>
<pre><code class=language-julia >@time A * B
@time opA * opB

v &#61; rand&#40;n&#41;
@time A * &#40;B * v&#41;
@time &#40;opA * opB&#41; * v;</code></pre><pre><code class=plaintext >  1.641701 seconds (2.49 M allocations: 241.537 MiB, 9.24% gc time)
  0.000003 seconds (4 allocations: 176 bytes)
  0.079493 seconds (260.28 k allocations: 13.712 MiB)
  0.020153 seconds (1.88 k allocations: 164.952 KiB)
</code></pre>
<h2 id=preallocated_operators ><a href="#preallocated_operators" class=header-anchor >Preallocated Operators</a></h2>
<p>It is often useful to reuse the memory used in a linear operator. If the operator is created from a matrix <code>A</code>, <code>PreallocatedLinearOperator&#40;A&#41;</code> automatically creates the underlying memory to store <code>A * v</code>, <code>transpose&#40;A&#41; * v</code> and <code>A&#39; * v</code>.</p>
<pre><code class=language-julia >m, n &#61; 50, 30
A &#61; rand&#40;50, 30&#41;
op1 &#61; PreallocatedLinearOperator&#40;A&#41;
op2 &#61; LinearOperator&#40;A&#41;
v &#61; rand&#40;n&#41;

op1 * v
al &#61; @allocated for i &#61; 1:100
  op1 * v
end
println&#40;&quot;Allocation of op1: &#36;al&quot;&#41;
op2 * v
al &#61; @allocated for i &#61; 1:100
  op2 * v
end
println&#40;&quot;Allocation of op2: &#36;al&quot;&#41;</code></pre><pre><code class=plaintext >Allocation of op1: 0
Allocation of op2: 49600
</code></pre>
<h2 id=inverse_operator ><a href="#inverse_operator" class=header-anchor >Inverse Operator</a></h2>
<p>Operators may be defined to represent &#40;approximate&#41; inverses.</p>
<pre><code class=language-julia >A &#61; rand&#40;5,5&#41;
A &#61; A&#39; * A
op &#61; opCholesky&#40;A&#41;  # Use, e.g., as a preconditioner
v &#61; rand&#40;5&#41;

norm&#40;A \ v - op * v&#41; / norm&#40;v&#41;</code></pre><pre><code class=plaintext >8.089364967775176e-11</code></pre>
<h2 id=lbfgs_operator ><a href="#lbfgs_operator" class=header-anchor >LBFGS Operator</a></h2>
<p>A useful operator is the Limited BFGS operator, which implements the BFGS update with limited memory used in nonlinear optimization. This update comes in both direct &#40;\(B_k\)&#41; and inverse &#40;\(H_k = B_k^{-1}\)&#41; form.</p>
\[
B_{k+1} = B_k + \frac{y_k y_k^T}{y_k^T s_k} - \frac{B_k s_k s_k^T B_k^T}{s_k^T B_k s_k}
\]
\[
H_{k+1} = \bigg(I - \frac{s_k y_k^T}{y_k^T s_k}\bigg)H_k\bigg(I - \frac{y_k s_k^T}{y_k^T s_k}\bigg) + \frac{s_k s_k^T}{y_k^T s_k}
\]
<pre><code class=language-julia >B &#61; LBFGSOperator&#40;5, scaling&#61;false&#41; # B₀ &#61; I
H &#61; InverseLBFGSOperator&#40;5, scaling&#61;false&#41; # H₀ &#61; I

s &#61; rand&#40;5&#41;
y &#61; rand&#40;5&#41;
push&#33;&#40;B, s, y&#41;
push&#33;&#40;H, s, y&#41;

q &#61; rand&#40;5&#41;
Bq &#61; q &#43; dot&#40;y, q&#41; / dot&#40;y, s&#41; * y - dot&#40;s, q&#41; / dot&#40;s, s&#41; * s
Hauxq &#61; q - dot&#40;s, q&#41; / dot&#40;y, s&#41; * y
Hq &#61; Hauxq - dot&#40;y, Hauxq&#41; / dot&#40;y, s&#41; * s &#43; dot&#40;s, q&#41; / dot&#40;y, s&#41; * s

norm&#40;B * q - Bq&#41;, norm&#40;H * q - Hq&#41;, norm&#40;B * H * q - q&#41;</code></pre><pre><code class=plaintext >(2.0014830212433605e-16, 2.7755575615628914e-16, 3.3306690738754696e-16)</code></pre>
<h2 id=application_heat_equation ><a href="#application_heat_equation" class=header-anchor >Application: Heat Equation</a></h2>
<p>Consider a square plate of size \(L \times L\) with no heat exchange on the boundaries. The Heat Equation and boundary conditions related to the temperature \(u(t,x,y)\) at time \(t\), position \((x,y)\) is given by</p>
\[
\frac{\partial u}{\partial t} = \alpha \bigg(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\bigg),
\]
<p>where \(\alpha > 0\), and</p>
\[
\frac{\partial u}{\partial x}(t,0,y) = \frac{\partial u}{\partial x}(t,L,y) =
\frac{\partial u}{\partial y}(t,x,0) = \frac{\partial u}{\partial y}(t,x,L) = 0.
\]
<p>Discretizing \(t\) into \([0,t_1,\dots,t_N]\) with \(\delta = t_{n+1} - t_n\), \(x \in [0,L]\) into \([x_1,x_2,\dots,x_m]\) with \(h = x_{i+1} - x_i\) and \(y\) accordingly, with \(h = y_{j+1} - y_j\), we define \(u^n_{i,j}\) as the approximation to \(u(t_n,x_i,y_j)\). The derivatives can be approximated by finite differences:</p>
\[
\begin{aligned}
  \frac{\partial u}{\partial t}(t_n,x_i,y_j) & \approx \frac{u^{n+1}_{i,j} - u^n_{i,j}}{\delta}
      \qquad \text{(Forward scheme in time)}; \\
  \frac{\partial u}{\partial x}(t_n,x_i,y_j) & \approx \frac{u^n_{i+1,j} - u^n_{i-1,j}}{2h}
      \qquad \text{(Central 1st order scheme)}; \\
  \frac{\partial^2 u}{\partial x^2}(t_n,x_i,y_j) & \approx \frac{u^n_{i+1,j} - 2u^n_{i,j} + u^n_{i-1,j}}{h^2}
      \qquad \text{(Central 2nd order scheme)}; \\
  \frac{\partial u}{\partial y}(t_n,x_i,y_j) & \approx \frac{u^n_{i,j+1} - u^n_{i,j-1}}{2h}
      \qquad \text{(Central 1st order scheme)}; \\
  \frac{\partial^2 u}{\partial y^2}(t_n,x_i,y_j) & \approx \frac{u^n_{i,j+1} - 2u^n_{i,j} + u^n_{i,j-1}}{h^2}
      \qquad \text{(Central 2nd order scheme)}.
\end{aligned}
\]
<p>Substituting into the PDE, we obtain</p>
\[
\frac{u^{n+1}_{i,j} - u^n_{i,j}}{\delta} = \frac{\alpha}{h^2}(-4u^n_{i,j} + u^n_{i-1,j} + u^n_{i+1,j} + u^n_{i,j-1} + u^n_{i,j+1}).
\]
<p>This can be written as</p>
\[
u^{n+1}_{i,j} = (1 - 4\gamma)u^n_{i,j} + \gamma\Big(u^n_{i-1,j} + u^n_{i+1,j} + u^n_{i,j-1} + u^n_{i,j+1}\Big),
\]
<p>where \(\gamma = \dfrac{\alpha\delta}{h^2}\).</p>
<p>To handle the boundary conditions, we need to introduce additional unknowns \(u_{0,j}\), \(u_{m+1,j}\), \(u_{i,0}\) and \(u_{i,m+1}\) for values \(x = -h\), \(x = L + h\), \(y = -h\) and \(y = L + h\), respectively. Although these values are outside the domain of interest, they help define the values inside the domain by being removed through the discretization of the boundary contitions</p>
\[
\frac{\partial u}{\partial x}(t_n,x_1,y_j) = \frac{\partial u}{\partial x}(t_n,x_m,y_j) = \frac{\partial u}{\partial y}(t_n,x_i,y_1) = \frac{\partial u}{\partial y}(t_n,x_i,y_m) = 0.
\]
<p>This leads to</p>
\[
u^n_{2,j} = u^n_{0,j}, \quad
u^n_{m+1,j} = u^n_{m-1,j}, \quad
u^n_{i,2} = u^n_{i,0}, \quad
u^n_{i,m+1} = u^n_{i,m-1}.
\]
<p>Note that in the PDE discretization, if \(u^n_{0,j}\), \(u^n_{m+1,j}\), \(u^n_{i,0}\) or \(u^n_{i,m+1}\) appear, we can substitute them by one of the inner mesh points. For instance, for \((i,j) = (1,2)\):</p>
\[
\begin{aligned}
u^{n+1}_{1,2} & = (1 - 4\gamma)u^n_{1,2} + \gamma\Big(u^n_{0,2} + u^n_{2,2} + u^n_{1,1} + u^n_{1,3}\Big) \\
& = (1 - 4\gamma)u^n_{1,2} + \gamma\Big(2u^n_{2,2} + u^n_{1,1} + u^n_{1,3}\Big).
\end{aligned}
\]
<p>Another example, for \((i,j) = (1,1)\):</p>
\[
\begin{aligned}
u^{n+1}_{1,1} & = (1 - 4\gamma)u^n_{1,1} + \gamma\Big(u^n_{0,1} + u^n_{2,1} + u^n_{1,0} + u^n_{1,2}\Big) \\
& = (1 - 4\gamma)u^n_{1,1} + \gamma\Big(2u^n_{2,1} + 2u^n_{1,2}\Big).
\end{aligned}
\]
<p>Now we define \(U^n = (u_{1,1}^n, u_{1,2}^n, \dots, u_{1,m}^n, u_{2,1}^n, \dots, u_{m,m}^n)^T\), for \(n = 0,\dots,N\). This way we can define the following recurrence relation:</p>
\[ U^{n+1} = AU^n, \]
<p>for some matrix \(A\).   This matrix has a very special structure. With \(m = 3\), which only has one interior  mesh point, it becomes the following:</p>
\[
  \begin{bmatrix}
  1 - 4\gamma & 2\gamma & 0 & 2\gamma & 0 & 0 & 0 & 0 & 0 \\
  \gamma & 1 - 4\gamma & \gamma & 0 & 2\gamma & 0 & 0 & 0 & 0 \\
  0 & 2\gamma & 1 - 4\gamma & 0 & 0 & 2\gamma & 0 & 0 & 0 \\
  \gamma & 0 & 0 & 1 - 4\gamma & 2\gamma & 0 & \gamma & 0 & 0 \\
  0 & \gamma & 0 & \gamma & 1 - 4\gamma & \gamma & 0 & \gamma & 0 \\
  0 & 0 & \gamma & 0 & 2\gamma & 1 - 4\gamma & 0 & 0 & \gamma \\
  0 & 0 & 0 & 2\gamma & 0 & 0 & 1 - 4\gamma & 2\gamma & 0 \\
  0 & 0 & 0 & 0 & 2\gamma & 0 & \gamma & 1 - 4\gamma & \gamma \\
  0 & 0 & 0 & 0 & 0 & 2\gamma & 0 & 2\gamma & 1 - 4\gamma
  \end{bmatrix}.
  \]
<p>For \(m > 3\), the above matrix can be written</p>
\[
  A = \begin{bmatrix}
  T & 2D \\
  D & T & D \\
  & D & T & D \\
  & & \ddots & \ddots & \ddots \\
  & & & D & T & D \\
  & & & & 2D & T
  \end{bmatrix},
  \]
<p>where \(T\) is a tridiagonal matrix and \(D = \gamma I\).</p>
<h4>Implementing</h4>
<p>Instead of creating the full matrix \(A\), we create \(A\) as an operator to save memory.</p>
<pre><code class=language-julia >function HeatEquationOp&#40;L, m, δ, α&#41;
  h &#61; L / &#40;m - 1&#41;
  γ &#61; α * δ / h^2
  κ &#61; 1 - 4γ

  Tprod&#40;v&#41; &#61; &#91;κ * v&#91;1&#93; &#43; 2γ * v&#91;2&#93;;
             &#91;γ * v&#91;i-1&#93; &#43; κ * v&#91;i&#93; &#43; γ * v&#91;i&#43;1&#93; for i &#61; 2:m-1&#93;;
              κ * v&#91;m&#93; &#43; 2γ * v&#91;m-1&#93;&#93;

  T &#61; LinearOperator&#40;Float64, m, m, false, false, Tprod&#41;
  D &#61; opEye&#40;m&#41; * γ

  function prod&#40;v&#41;
    Hv &#61; zeros&#40;m^2&#41;
    Hv&#91;1:m&#93; .&#61; &#91;T  2D&#93; * v&#91;1:2m&#93;
    for i &#61; 2:m-1
      Hv&#91;&#40;i-1&#41;*m&#43;1:i*m&#93; .&#61; &#91;D T D&#93; * v&#91;&#40;i-2&#41;*m&#43;1:&#40;i&#43;1&#41;*m&#93;
    end
    Hv&#91;end-m&#43;1:end&#93; .&#61; &#91;2D T&#93; * v&#91;end-2m&#43;1:end&#93;
    return Hv
  end

  return LinearOperator&#40;Float64, m^2, m^2, false, false, prod&#41;
end</code></pre><pre><code class=plaintext >HeatEquationOp (generic function with 1 method)</code></pre>
<p>Here is an example of this operator.</p>
<pre><code class=language-julia >A &#61; HeatEquationOp&#40;1.0, 3, 0.1, 0.1&#41;
Matrix&#40;A&#41;</code></pre><pre><code class=plaintext >9×9 Array{Float64,2}:
 0.84  0.08  0.0   0.08  0.0   0.0   0.0   0.0   0.0
 0.04  0.84  0.04  0.0   0.08  0.0   0.0   0.0   0.0
 0.0   0.08  0.84  0.0   0.0   0.08  0.0   0.0   0.0
 0.04  0.0   0.0   0.84  0.08  0.0   0.04  0.0   0.0
 0.0   0.04  0.0   0.04  0.84  0.04  0.0   0.04  0.0
 0.0   0.0   0.04  0.0   0.08  0.84  0.0   0.0   0.04
 0.0   0.0   0.0   0.08  0.0   0.0   0.84  0.08  0.0
 0.0   0.0   0.0   0.0   0.08  0.0   0.04  0.84  0.04
 0.0   0.0   0.0   0.0   0.0   0.08  0.0   0.08  0.84</code></pre>
<p>This example shows the sparsisty pattern.</p>
<pre><code class=language-julia >using SparseArrays, Plots
gr&#40;size&#61;&#40;600,600&#41;&#41;

A &#61; HeatEquationOp&#40;1.0, 20, 0.1, 0.1&#41;
spy&#40;sparse&#40;Matrix&#40;A&#41;&#41;&#41;</code></pre>
<p><img src="/previews/PR1/assets/pages/tutorials/introduction-to-linear-operators/code/output/spy.png" alt="Sparsity of A"> The next function creates a <code>HeatEquationOp</code> operator and the linearized vector <code>U</code> with starting values.</p>
<pre><code class=language-julia >function HeatEquation&#40;u0, L, m, δ, α&#41;
  h &#61; L / &#40;m - 1&#41;
  U &#61; zeros&#40;m^2&#41;
  for i &#61; 1:m
    x &#61; &#40;i - 1&#41; * h
    for j &#61; 1:m
      y &#61; &#40;j - 1&#41; * h
      U&#91;&#40;i - 1&#41;*m &#43; j&#93; &#61; u0&#40;x, y&#41;
    end
  end
  A &#61; HeatEquationOp&#40;L, m, δ, α&#41;

  return U, A
end</code></pre><pre><code class=plaintext >HeatEquation (generic function with 1 method)</code></pre>
<p>Now, anytime we want to make a time step, we can simply compute <code>A * U</code>.</p>
<pre><code class=language-julia >const dark_purple &#61; Colors.RGB&#40;0.584, 0.345, 0.698&#41;
const dark_red    &#61; Colors.RGB&#40;0.796, 0.235, 0.200&#41;
const dark_green  &#61; Colors.RGB&#40;0.220, 0.596, 0.149&#41;
const black       &#61; Colors.RGB&#40;0.0, 0.0, 0.0&#41;
colors &#61; &#91;black, dark_green, dark_green, dark_red, dark_red, dark_purple, dark_purple&#93;

L &#61; 5
u0&#40;x, y&#41; &#61; begin
  d &#61; &#91;&#40;x,y&#41; -&gt; &#40;&#40;x - sin&#40;2π/3*i&#41;&#41;^2 &#43; &#40;y - cos&#40;2π/3*i&#41;&#41;^2&#41;^2 for i &#61; 1:3&#93;
  xx, yy &#61; x - L / 2, y - L / 2
  return 3*exp&#40;-sqrt&#40;2&#41;*d&#91;1&#93;&#40;xx,yy&#41;&#41; &#43; 2*exp&#40;-d&#91;2&#93;&#40;xx,yy&#41;&#41; &#43; exp&#40;-4*d&#91;3&#93;&#40;xx,yy&#41;&#41;
end

grid &#61; range&#40;0, L, length&#61;50&#41;
maxu &#61; maximum&#40;&#91;u0&#40;xi,yi&#41; for xi in grid, yi in grid&#93;&#41;
p &#61; plot&#40;; leg&#61;false, size&#61;&#40;1000,500&#41;, layout&#61;@layout &#91;a b&#93;&#41;
surface&#33;&#40;p&#91;1&#93;, grid, grid, u0, c&#61;cgrad&#40;colors&#41;, camera&#61;&#40;50,70&#41;&#41;
contour&#33;&#40;p&#91;2&#93;, grid, grid, u0, levels&#61;range&#40;0.1, maxu, length&#61;50&#41;, c&#61;cgrad&#40;colors&#41;&#41;</code></pre>
<img src="/previews/PR1/assets/pages/tutorials/introduction-to-linear-operators/code/output/surface1.png" alt="Surface and contour plot">
<p>The following two blocks are a visualization of the solution of the Heat Equation. The first block show images of at different time steps.</p>
<pre><code class=language-julia >L &#61; 5
m &#61; 30
δ &#61; 0.01
α &#61; 0.5

U0, A &#61; HeatEquation&#40;u0, L, m, δ, α&#41;
U &#61; copy&#40;U0&#41;

plot_rows &#61; 4
plot_cols &#61; 4
plots &#61; &#91;&#93;

Δt &#61; 10

for i &#61; 1:plot_rows
  for j &#61; 1:plot_cols
    global U

    local p &#61; surface&#40;reshape&#40;U, m, m&#41;, leg&#61;false, c&#61;cgrad&#40;colors&#41;, camera&#61;&#40;50,70&#41;&#41;
    zlims&#33;&#40;0, maximum&#40;U0&#41;&#41;
    xticks&#33;&#40;Float64&#91;&#93;&#41;
    yticks&#33;&#40;Float64&#91;&#93;&#41;
    k &#61; &#40;i - 1&#41; * plot_cols &#43; j
    title&#33;&#40;&quot;t &#61; &#36;&#40;round&#40;k * Δt * δ, digits&#61;3&#41;&#41;&quot;&#41;
    push&#33;&#40;plots, p&#41;

    for t &#61; 1:Δt
      U &#61; A * U
    end
  end
end
plot&#40;plots..., layout&#61;&#40;plot_rows, plot_cols&#41;, size&#61;&#40;1000, plot_rows * 250&#41;&#41;</code></pre>
<img src="/previews/PR1/assets/pages/tutorials/introduction-to-linear-operators/code/output/surface2.png" alt="Surfaces along the time">
<p>The second block shows an animation.</p>
<pre><code class=language-julia >U0, A &#61; HeatEquation&#40;u0, L, m, δ, α&#41;
U &#61; copy&#40;U0&#41;

Δt &#61; 2.5

anim &#61; Animation&#40;&#41;
for i &#61; 1:60
  global U

  rU &#61; reshape&#40;U, m, m&#41;
  local p &#61; plot&#40;; leg&#61;false, size&#61;&#40;1000,500&#41;, layout&#61;@layout &#91;a b&#93;&#41;
  surface&#33;&#40;p&#91;1&#93;, rU, c&#61;cgrad&#40;colors&#41;, camera&#61;&#40;50,70&#41;&#41;
  contour&#33;&#40;p&#91;2&#93;, rU, levels&#61;range&#40;0.1, maximum&#40;U0&#41;, length&#61;50&#41;, c&#61;cgrad&#40;colors&#41;&#41;
  zlims&#33;&#40;0, maximum&#40;U0&#41;&#41;
  frame&#40;anim&#41;

  for t &#61; 1:Δt
    U &#61; A * U
  end
end</code></pre>
<p><span style="color:red;">// Image matching '/assets/pages/tutorials/introduction-to-linear-operators/code/heat-equation.gif' not found. //</span></p>

<div class=page-foot >
  <div class=copyright >
    &copy; Abel Soares Siqueira. Last modified: April 22, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>  
    
        <script src="/previews/PR1/libs/katex/katex.min.js"></script>
<script src="/previews/PR1/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>